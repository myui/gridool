/*
 * @(#)$Id$
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 *
 * Copyright 2009-2011 Makoto YUI
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 * Contributors:
 *     Makoto YUI - initial implementation
 */options{  JDK_VERSION = "1.5";  static = false;}PARSER_BEGIN(SqletParser)package gridool.sqlet.parser;

import gridool.sqlet.SqletException;
import gridool.sqlet.SqletModule;

public class SqletParser {

    /** parse state variables */
    private Token currentToken = null;

	public SqletModule parse() {		
	}

	private static String unquote(String s) {
        return s.substring(1, s.length() - 1);
    }

	private static String removeSemiColon(String s) {		int len = s.length();
		return s.substring(len, len - 1).trim();
	}
    
}PARSER_END(SqletParser)
TOKEN_MGR_DECLS :
{
	final IntStack stateStack = new IntStack();

	public void pushState(int state) {
		stateStack.push(state);
	}

	private void pushState() {
		pushState(curLexState);
	}
	
	public void popState() {
		if(stateStack.isEmpty()) {
			System.err.println("Line: " + input_stream.getEndLine());
		} else {
			final int state = stateStack.pop();
			SwitchTo(state);
		}
	}
}

TOKEN :
{
  < StartLoadPartition : ("load" | "LOAD") <Skip_> ("partitions" | "PARTITIONS") <Skip_> > : LOAD_STMT | < StartLoadReducers : ("load" | "LOAD") <Skip_> ("reducers" | "REDUCERS") <Skip_> > : LOAD_STMT 
}

< LOAD_STMT >
TOKEN :
{  < LoadStmt_IntoCatalog : ("into" | "INTO") <Skip_> ("catalog" | "CATALOG") <Skip_> > { pushState(KEYWORD); } : LOAD_STMT
| < LoadStmt_FromFile : ("from" | "FROM") <Skip_> ("file" | "FILE") <Skip_> > { pushState(KEYWORD); }
| < LoadStmt_FromTable : ("from" | "FROM") <Skip_ > ("table" | "TABLE") <Skip_> > { pushState(KEYWORD); }
}

TOKEN:
{  < BeginMapShuffle : "map-and-shuffle" "{" <Skip_> > : IN_MAP_DIRECTIVE
| < BeginMapNoCompile : "map#no_compile" "{" <Skip_> > : IN_MAP_DIRECTIVE
}

< IN_MAP_DIRECTIVE >
TOKEN :
{
  < SelectQuery : ( "SELECT" | "select" ) <Skip_> (~[";"])+ ";" > : END_MAP_DIRECTIVE
}

< END_MAP_DIRECTIVE >
TOKEN:
{  
  < EndMapRbrace : "}" > : DEFAULT
| < OtherThanRbrace : ( ~["}"] | "\\}" )+ > : DEFAULT
}

< KEYWORD >
TOKEN :
{
  < QuotedIdentifier : "\"" < Identifier > "\"" > { popState(); }
| < Identifier : ( < Letter > | "_") ( < Letter > | < Digit > | ["-","."] )* > { popState(); }
| < URI : ("\"" < URILiteral > "\"") | ("'" < URILiteral > "'") > { popState(); }| < #URILiteral : ([ "0"-"9","a"-"z","A"-"Z","-", "_", ".", "#", ":", "/", "(", ")" ])+ >
}

TOKEN :
{
  < #Skip_ : (<WhitespaceChar>)+ >
| < #WhitespaceChar : ["\t", "\r", "\n", " "] >
| < #Letter: ["A"-"Z","a"-"z"]>
| < #Digit : ["0"-"9"] >
}

SPECIAL_TOKEN :
{
  < LINE_COMMENT: "--"(~["\r","\n"])* >
| < MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/" >
}

SKIP :
{
  < (<WhitespaceChar>)+ >
}

SqletModule parseCompilationUnit() throws SqletException:
{
  	SqletModule m = new SqletModule();}
{
 	(		  parseLoadPartitions(m)
		| parseLoadReducers(m)
		| parseMapDirective(m)
 	)+	<EOF>
	{
		return m;
	}
}

void parseLoadPartitions(SqletModule m) throws SqletException :
{
	String catalogName = SystemCatalog.DEFAULT_CATALOG_NAME;
}
{
	currentToken = < StartLoadPartition >
	[
		currentToken = < LoadStmt_IntoCatalog >
		catalogName = ObjectName()
	]
	(
		parseLoadPartitionsFromFile(m, catalogName) | paserLoadPartitionsFromTable(m, catalogName)
	)}

void parseLoadPartitionsFromFile(SqletModule m, String catalogName) throws SqletException :
{}
{
  	currentToken = < LoadStmt_FromFile >
	currentToken = < URI >
	{		String filepath = unquote(currentToken.image);
		PartitioningConf conf = m.getPartitioningConf(catalogName);
		if(conf == null) {			throw new SqletException(ErrorType.configFailed, "PartitioningConf is not found in catalog: " + catalogName);
		}
		conf.loadSettings(filepath);
	}
}

void paserLoadPartitionsFromTable(SqletModule m) throws SqletException :
{
	String tblName = null;
}
{
  	currentToken = < LoadStmt_FromTable >
	tblName = ObjectName()
	{
	  	assert (tblName != null);
		PartitioningConf conf = m.getPartitioningConf();
		if(conf == null) {
			throw new SqletException(ErrorType.configFailed, "PartitioningConf is not found in catalog: " + catalogName);
		}
		throw new SqletException(ErrorType.unsupported, "'load partitions from table' is not supported yet");
	}
}

void parseLoadReducers(SqletModule m) throws SqletException :
{}
{
	parseLoadReducersFromFile(m) | parseLoadReducersFromTable(m)
}

void parseLoadReducersFromFile(SqletModule m) throws SqletException :
{}
{
	currentToken = < LoadReducersFromFile >
	currentToken = < URI >
	{
		String filepath = unquote(currentToken.image);
		m.getMapReduceConf().loadReducers(filepath);
	}	
}

void parseLoadReducersFromTable(SqletModule m) throws SqletException :
{
	String tblName = null;
}
{
  	currentToken = < LoadReducersFromTable >
	tblName = ObjectName()
	{
	  	assert tblName != null;
		m.getMapReduceConf().loadReducers(tblName);
	}
}

void parseMapDirective(SqletModule mod) throws SqletException :
{}
{
	parseMapCompile(mod) | parseMapNoCompiple(mod)
  	currentToken = < EndMapRbrace >}

void parseMapShuffle(SqletModule mod) throws SqletException :
{}
{
  	currentToken = < BEGIN_MAP_SHUFFLE >
    currentToken = < SelectQuery >
    {		String selectQuery = removeSemiColon(currentToken.image);
		SqletCommand cmd = new SqletCommand(CommandType.MAP_SHUFFLE, selectQuery);
		
    }
    currentToken = < EndMapRbrace >
}

void parseMapNoCompiple(SqletModule mod) throws SqletException :
{}
{
  	currentToken = < BEGIN_MAP_NOCOMPILE >
  	currentToken = < OtherThanRbrace >
  	{
  	  	String rawQuery = currentToken.image;
  	  	SqletCommand cmd = new SqletCommand(CommandType.MAP_ONLY, rawQuery);		
  	}
  	currentToken = < EndMapRbrace >
}

String ObjectName():
{}
{
    <Identifier>       { return token.image; }
  | <QuotedIdentifier> { String s = token.image; return s.substring(1, s.length() - 1); }
}
