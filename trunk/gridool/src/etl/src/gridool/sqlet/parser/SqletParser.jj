/*
 * @(#)$Id$
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 *
 * Copyright 2009-2011 Makoto YUI
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 * Contributors:
 *     Makoto YUI - initial implementation
 */options{  JDK_VERSION = "1.5";  static = false;}PARSER_BEGIN(SqletParser)package gridool.sqlet.parser;

import gridool.sqlet.SqletException;
import gridool.sqlet.SqletException.SqletErrorType;
import gridool.sqlet.SqletModule;
import gridool.sqlet.api.CommandType;
import gridool.sqlet.api.ErrorType;
import gridool.sqlet.api.SqletCommand;
import gridool.sqlet.catalog.MapReduceConf;
import gridool.sqlet.catalog.PartitioningConf;
import gridool.sqlet.catalog.SystemCatalog;

public class SqletParser {

    /** parse state variables */
    private Token currentToken = null;

    private SystemCatalog catalog;

    public void setSystemCatalog(SystemCatalog catalog) {
        this.catalog = catalog;
    }

	public SqletModule parse() throws SqletException {	  	assert catalog != null;		final SqletModule module;
        try {
            module = parseCompilationUnit();
        } catch (SqletException se) {
            throw se;
        } catch (ParseException pe) {
            throw new SqletException(SqletErrorType.parseError, pe);
        } catch (Throwable te) {
            throw new SqletException(SqletErrorType.parseError, te);
        }
        return module;
	}

	private static String unquote(String s) {
        return s.substring(1, s.length() - 1);
    }

	private static String removeSemiColon(String s) {		int len = s.length();
		return s.substring(len, len - 1).trim();
	}
    
}PARSER_END(SqletParser)
TOKEN_MGR_DECLS :
{
	final IntStack stateStack = new IntStack();

	public void pushState(int state) {
		stateStack.push(state);
	}

	private void pushState() {
		pushState(curLexState);
	}
	
	public void popState() {
		if(stateStack.isEmpty()) {
			System.err.println("Line: " + input_stream.getEndLine());
		} else {
			final int state = stateStack.pop();
			SwitchTo(state);
		}
	}
}

TOKEN :
{
  < StartLoadPartition : ("load" | "LOAD") <Skip_> ("partitions" | "PARTITIONS") <Skip_> > : LOAD_STMT | < StartLoadReducers : ("load" | "LOAD") <Skip_> ("reducers" | "REDUCERS") <Skip_> > : LOAD_STMT 
}

< LOAD_STMT >
TOKEN :
{  < LoadStmt_IntoCatalog : ("into" | "INTO") <Skip_> ("catalog" | "CATALOG") <Skip_> > { pushState(LOAD_STMT); } : KEYWORD
| < LoadStmt_FromFile : ("from" | "FROM") <Skip_> ("file" | "FILE") <Skip_> > : KEYWORD
| < LoadStmt_FromTable : ("from" | "FROM") <Skip_ > ("table" | "TABLE") <Skip_> > : KEYWORD
}

TOKEN:
{  < BeginMapShuffle : "map-and-shuffle" "{" <Skip_> > : IN_MAP_DIRECTIVE
| < BeginMapNoCompile : "map#no_compile" "{" <Skip_> > : IN_MAP_DIRECTIVE
}

< IN_MAP_DIRECTIVE >
TOKEN :
{
  < SelectQuery : ( "SELECT" | "select" ) <Skip_> (~[";"])+ ";" > : END_MAP_DIRECTIVE
| < OtherThanRbrace : ( ~["}"] | "\\}" )+ > : END_MAP_DIRECTIVE
}

< END_MAP_DIRECTIVE >
TOKEN:
{  
  < EndMapRbrace : "}" (";")? >
| < EndMapUsingCatalog : "}" <Skip_> ("using"|"USING") <Skip_> ("catalog"|"CATALOG") <Skip_> > { pushState(END_MAP_DIRECTIVE); } : KEYWORD
| < EndMapSemiColon : ";" > 
}

< KEYWORD >
TOKEN :
{
  < QuotedIdentifier : "\"" < Identifier > "\"" > { popState(); }
| < Identifier : ( < Letter > | "_") ( < Letter > | < Digit > | ["-","."] )* > { popState(); }
| < URI : ("\"" < URILiteral > "\"") | ("'" < URILiteral > "'") > { popState(); }| < #URILiteral : ([ "0"-"9","a"-"z","A"-"Z","-", "_", ".", "#", ":", "/", "(", ")" ])+ >
}

TOKEN :
{
  < #Skip_ : (<WhitespaceChar>)+ >
| < #WhitespaceChar : ["\t", "\r", "\n", " "] >
| < #Letter: ["A"-"Z","a"-"z"]>
| < #Digit : ["0"-"9"] >
}

SPECIAL_TOKEN :
{
  < LINE_COMMENT: "--"(~["\r","\n"])* >
| < MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/" >
}

SKIP :
{
  < (<WhitespaceChar>)+ >
}

SqletModule parseCompilationUnit() throws SqletException:
{
  	SqletModule m = new SqletModule(catalog);}
{
 	(LOOKAHEAD(2)		  parseLoadPartitions(m)
		| parseLoadReducers(m)
		| parseMapDirective(m)
 	)+	<EOF>
	{
		return m;
	}
}

void parseLoadPartitions(SqletModule m) throws SqletException :
{
	String catalogName = SystemCatalog.DEFAULT_CATALOG_NAME;
	PartitioningConf conf = null;
}
{
	currentToken = < StartLoadPartition >
	[
		currentToken = < LoadStmt_IntoCatalog >
		catalogName = ObjectName()
	]
	{		conf = m.getPartitioningConf(catalogName);
		if(conf == null) {
			throw new SqletException(SqletErrorType.configFailed, "PartitioningConf is not found in catalog: " + catalogName);
		}
	}
	(
		parseLoadPartitionsFromFile(conf) | paserLoadPartitionsFromTable(conf)
	)}

void parseLoadPartitionsFromFile(PartitioningConf conf) throws SqletException :
{}
{
  	currentToken = < LoadStmt_FromFile >
	currentToken = < URI >
	{		String filepath = unquote(currentToken.image);
		conf.loadSettings(filepath);
	}
}

void paserLoadPartitionsFromTable(PartitioningConf conf) throws SqletException :
{
	String tblName = null;
}
{
  	currentToken = < LoadStmt_FromTable >
	tblName = ObjectName()
	{
	  	assert (tblName != null);
		throw new SqletException(SqletErrorType.unsupported, "'load partitions from table' is not supported yet");
	}
}

void parseLoadReducers(SqletModule m) throws SqletException :
{
	String catalogName = SystemCatalog.DEFAULT_CATALOG_NAME;
	MapReduceConf conf = null;
}
{
	currentToken = < StartLoadPartition >
	[
		currentToken = < LoadStmt_IntoCatalog >
		catalogName = ObjectName()
	]
	{
		conf = m.getMapReduceConf(catalogName);
		if(conf == null) {
			throw new SqletException(SqletErrorType.configFailed, "MapReduceConf is not found in catalog: " + catalogName);
		}
	}
	(
		parseLoadReducersFromFile(conf) | parseLoadReducersFromTable(conf)
	)
}

void parseLoadReducersFromFile(MapReduceConf conf) throws SqletException :
{}
{
	currentToken = < LoadStmt_FromFile >
	currentToken = < URI >
	{
		String filepath = unquote(currentToken.image);
		conf.loadReducers(filepath);
	}	
}

void parseLoadReducersFromTable(MapReduceConf conf) throws SqletException :
{
	String tblName = null;
}
{
  	currentToken = < LoadStmt_FromTable >
	tblName = ObjectName()
	{
	  	assert tblName != null;
		throw new SqletException(SqletErrorType.unsupported, "'load reducers from table' is not supported yet");
	}
}

void parseMapDirective(SqletModule mod) throws SqletException :
{}
{
	(	  parseMapShuffle(mod) | parseMapNoCompile(mod)
	)
  	currentToken = < EndMapRbrace >}

void parseMapShuffle(SqletModule m) throws SqletException :
{
	String catalogName = SystemCatalog.DEFAULT_CATALOG_NAME;
	String selectQuery = null;
}
{
  	currentToken = < BeginMapShuffle >
    currentToken = < SelectQuery >
    {		selectQuery = removeSemiColon(currentToken.image);
    }
  	(
  	  	(  	  	  		  	currentToken = < EndMapUsingCatalog >
		  	catalogName = ObjectName()
		  	currentToken = < EndMapSemiColon >
  	 	)
  	 |
  	 	currentToken = < EndMapRbrace >
  	)
  	{
  	  	assert selectQuery != null;		SqletCommand cmd = new SqletCommand(CommandType.MAP_SHUFFLE, selectQuery);
        cmd.setCatalogName(catalogName);
		m.offerCommand(cmd);
  	}
}

void parseMapNoCompile(SqletModule m) throws SqletException :
{
	String catalogName = SystemCatalog.DEFAULT_CATALOG_NAME;
	String rawQuery = null;
}
{
  	currentToken = < BeginMapNoCompile >
  	currentToken = < OtherThanRbrace >
  	{
  	  	rawQuery = currentToken.image;
  	}
  	(
  	  	(  	  	  
		  	currentToken = < EndMapUsingCatalog >
		  	catalogName = ObjectName()
		  	currentToken = < EndMapSemiColon >
  	 	)
  	 |
  	 	currentToken = < EndMapRbrace >
  	)
  	{
  	  	assert rawQuery != null;
  	   	SqletCommand cmd = new SqletCommand(CommandType.MAP_NO_COMPILE, rawQuery);
  	   	cmd.setCatalogName(catalogName);
		m.offerCommand(cmd);  	}
}

String ObjectName():
{}
{
    <Identifier>       { return token.image; }
  | <QuotedIdentifier> { String s = token.image; return s.substring(1, s.length() - 1); }
}
